#!/usr/bin/env bash
set -euo pipefail
cd $(dirname "${BASH_SOURCE[0]}")

IS_INTEGER='^[0-9]+$'
VALID_MOUNT_COMM='^(uuid|label|name)$'

show_help() {
    echo "
Usage of $(basename "$0"):
    -H, --hostname      The hostname of the container, also used by avahi
                            Default: plex-uflix
    -r, --mount-root    Where the media will be mounted on the host
                            Default: /var/run/uflix
    -p, --ssh-port      The SSH port to expose from the container
                            Default: 2200
    -d, --data          REQUIRED: Device to use as storage can be any of:
                            UUID, PARTUUID, sdXY, Label, PartLabel, ID,
                            any device file, any normal directory,
    -L, --label         What to call the media when its mounted on the host,
                            can be: label, uuid, name
                            Default: name
    "
    if [[ ${1:-} ]]; then
        exit 64
    else
        exit 0
    fi
}

warn() {
    echo -e "\e[0;33m[WARNING] ${@}\e[0m" 1>&2
}

error() {
    echo -e "\e[0;31m[ERROR] ${@}\e[0m" 1>&2
}

info() {
    echo "[INFO] ${@}"
}

PLEX_DEVICE=
SSH_PORT=2200
HOSTNAME="plex-uflix"
MOUNT_HOME="/var/run/uflix"
MOUNT_NAME_COMM="name"

# Argument parsing
VAR_CHANGE=
for ARG in "$@"; do
    case "$ARG" in
        "-h"|"--help")
            show_help
            ;;
        "-H"|"--hostname")
            VAR_CHANGE="HOSTNAME"
            ;;
        "-r"|"--mount-root")
            VAR_CHANGE="MOUNT_HOME"
            ;;
        "-p"|"--ssh-port")
            VAR_CHANGE="SSH_PORT"
            ;;
        "-L"|"--label")
            VAR_CHANGE="MOUNT_NAME_COMM"
            ;;
        "-d"|"--data")
            VAR_CHANGE="PLEX_DEVICE"
            ;;
        *)
            if [[ ${VAR_CHANGE:-} ]]; then
                eval "$VAR_CHANGE='$ARG'"
                VAR_CHANGE=
            else
                error "Could not understand argument '$ARG'."
                show_help true
            fi
    esac
done

# Arguments testing

if [[ ! ${PLEX_DEVICE:-} ]]; then
    error "You must specify at least one device for plex to use."
    echo "Specify this with the -d or --device flag."
    echo "Use the -h or --help flag for more options."
    exit 64
fi

if ! [[ $SSH_PORT =~ $IS_INTEGER && $SSH_PORT -ge 1 && $SSH_PORT -le 65535 ]]
then
    error "The SSH port must be a number between 1 and 65535 inclusive"
    echo "'$SSH_PORT' was given as a port number."
    exit 64
fi

if ! [[ $MOUNT_NAME_COMM =~ $VALID_MOUNT_COMM ]]; then
    error "Label must be one of: label, uuid, basename."
    echo "'$MOUNT_NAME_COMM' is unrecognized."
fi

if [[ $(id -u) != 0 ]]; then
    error "Please run this as a root user"
    exit 64
fi

mkdir -p "$MOUNT_HOME"
if [[ -d $MOUNT_HOME ]]; then
    CLEANUP=("warn not removing '$MOUNT_HOME'")
else
    CLEANUP=("rmdir '$MOUNT_HOME' || true")
fi

cleanup() {
    echo
    info "Cleaning up..."
    for ((i=${#CLEANUP[@]}-1; i >= 0; i--)); do
        local JOB="${CLEANUP[$i]}"
        info "Running $JOB..."
        eval "$JOB"
    done
}

trap cleanup TERM EXIT

mount=redir_mount
umount=redir_umount

redir_mount() {
    info "Mounting '$1' onto '$2'..."
    mount "${@:3}" "$1" "$2"
}

redir_umount() {
    info "Unmounting '$1'..."
    umount "${@:2}" "$1"
}

label() {
    local DEVICE="$1"
    if [[ -b $DEVICE ]]; then
        lsblk -o $MOUNT_NAME_COMM -n "$DEVICE"
    else
        basename "$DEVICE"
    fi
}

mount_it() {
    local COMMAND="$1"
    local OUTPUT="$2"
    local TARGET=$(readlink -f "$3")
    local LABEL=$(label "$TARGET")
    local DIRECTORY=$(readlink -f "$MOUNT_HOME/$LABEL")

    if [[ $DIRECTORY != $TARGET ]]; then
        # create a directory for mounting
        mkdir -p "$DIRECTORY"
        CLEANUP+=("rmdir '$DIRECTORY'")

        # mount the device
        mount_$COMMAND "$TARGET" "$DIRECTORY"
        CLEANUP+=("cleanup_$COMMAND '$TARGET' '$DIRECTORY'")
    else
        warn "'$TARGET' and '$DIRECTORY' are equal, not mounting."
    fi

    # return the mountpoint
    eval "$OUTPUT='$DIRECTORY'"
}

mount_directory() {
    $mount "$1" "$2" --bind
}

cleanup_directory() {
    $umount "$2" || true
}

mount_extfour()  {
    $mount "$1" "$2"
}

cleanup_extfour() {
    $umount "$2" || true
}

mount_luks() {
    local LUKS_DEV="$1"
    local MOUNT_POINT="$2"
    local MAPPED_DEV="uflix-$(basename $1)"
    local MAPPED_DEV_PATH="/dev/mapper/$MAPPED_DEV"

    # make sure dm-crypt & dm-mod module is loaded
    modprobe dm-crypt
    modprobe dm-mod

    # Open the encrypted drive
    cryptsetup open --type luks $LUKS_DEV $MAPPED_DEV
    $mount $MAPPED_DEV_PATH $MOUNT_POINT
}

cleanup_luks() {
    local MAPPED_DEV="uflix-$(basename $1)"
    local MOUNT_POINT="$2"
    $umount "$MOUNT_POINT" || true
    cryptsetup remove "$MAPPED_DEV" || true
}

find_dev() {
    local TARGET="$1"

    # is it just a path to a device file?
    if [[ -b $TARGET ]]; then
        echo "$TARGET"
        return
    fi

    # some block device specified by uuid, etc.
    local DEVICE=
    local DEVICES=(/dev/disk/*/$TARGET /dev/$TARGET)
    for DEVICE in "${DEVICES[@]}"; do
        if [[ -b $DEVICE ]]; then
            echo $(readlink -f $DEVICE)
            return
        fi
    done
}

multimount() {
    local OUTPUT="$1"
    local TARGET="$2"

    # maybe its a normal directory
    if [[ -d $TARGET ]]; then
        mount_it directory "$OUTPUT" "$TARGET"
        return
    fi

    # it could be some block device file
    info "Trying to find $TARGET..."
    local DEVICE=$(find_dev "$TARGET")
    info "Found $DEVICE !"
    if [[ $DEVICE ]]; then

        # is this device already mounted?
        local MOUNTED=($(cat /proc/mounts | grep ^$DEVICE || true))
        if [[ ${MOUNTED:-} ]]; then
            mount_it directory "$OUTPUT" "${MOUNTED[1]}"
            return
        fi

        # what's the file system?
        info "Detecting file system of $DEVICE..."
        local FSTYPE=$(lsblk -o FSTYPE -n $DEVICE)
        info "Detected $FSTYPE on $DEVICE !"
        case $FSTYPE in
            "ext4")
                mount_it extfour "$OUTPUT" "$DEVICE"
                return
                ;;
            "crypto_LUKS")
                mount_it luks "$OUTPUT" "$DEVICE"
                return
                ;;
            *)
                error "The $FSTYPE filesystem is not supported."
                ;;
        esac
    fi

    # no other options, exit
    error "Could not find any location using $TARGET"
    exit 64
}

multimount PLEX_MOUNT "$PLEX_DEVICE"

echo -e "\e[0;32m
======================
| Starting Container |
======================\e[0m"

docker run \
    --rm \
    -h "$HOSTNAME" \
    -p $SSH_PORT:22 \
    -v "$PLEX_MOUNT":"$PLEX_HOME" \
    -p 32400:32400 \
    -p 32400:32400/udp \
    -p 32469:32469 \
    -p 32469:32469/udp \
    -p 5353:5353/udp \
    -p 1900:1900/udp \
    uflix/main

